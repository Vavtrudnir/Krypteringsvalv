"""
Core cryptography module for Hemliga valvet.
Implements bcrypt key derivation and AES-256-GCM encryption.
"""

import os
import struct
from typing import Tuple, Union

from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend
import bcrypt


class CryptoError(Exception):
    """Cryptography-related errors."""
    pass


class CryptoManager:
    """Handles all cryptographic operations for the vault."""
    
    # Constants for bcrypt
    BCRYPT_ROUNDS = 12  # Standard secure rounds (can be adjusted for performance)
    BCRYPT_SALT_SIZE = 16  # bcrypt generates its own salt
    
    SALT_SIZE = 16  # bytes
    NONCE_SIZE = 12  # bytes for AES-GCM
    KEY_SIZE = 32  # bytes for AES-256
    
    def __init__(self):
        self.backend = default_backend()
    
    def generate_salt(self) -> bytes:
        """Generate a random salt using bcrypt."""
        return bcrypt.gensalt(self.BCRYPT_ROUNDS)
    
    def generate_nonce(self) -> bytes:
        """Generate a random 12-byte nonce for AES-GCM."""
        return os.urandom(self.NONCE_SIZE)
    
    def derive_key(self, password: str, salt: bytes, fast_mode: bool = False) -> bytes:
        """
        Derive encryption key from password using bcrypt.
        
        Args:
            password: User password
            salt: bcrypt salt (generated by bcrypt.gensalt())
            fast_mode: Use fewer rounds for faster performance (8 rounds instead of 12)
            
        Returns:
            32-byte encryption key
        """
        # bcrypt generates its own salt, but we'll use the provided salt for consistency
        rounds = 8 if fast_mode else self.BCRYPT_ROUNDS
        
        # Use bcrypt to hash the password
        password_bytes = password.encode('utf-8')
        
        # bcrypt.hashpw returns the full hash (including salt and parameters)
        # We'll use this as our key derivation
        try:
            # Use bcrypt to derive a 32-byte key
            bcrypt_hash = bcrypt.hashpw(password_bytes, salt)
            
            # bcrypt output is 60 bytes, we need exactly 32 bytes for AES-256
            # Use the first 32 bytes as our key
            key = bcrypt_hash[:self.KEY_SIZE]
            
            # ðŸ”’ Critical: Clear password from memory immediately
            password_bytes = b'\x00' * len(password_bytes)
            
            return key
            
        except Exception as e:
            # Clear password on error
            password_bytes = b'\x00' * len(password_bytes)
            raise CryptoError(f"Key derivation failed: {str(e)}")
    
    def encrypt(self, data: bytes, key: bytes, aad: bytes = b"") -> Tuple[bytes, bytes]:
        """
        Encrypt data using AES-256-GCM.
        
        Args:
            data: Plaintext to encrypt
            key: 32-byte encryption key
            aad: Additional authenticated data
            
        Returns:
            Tuple of (nonce, ciphertext)
        """
        if len(key) != self.KEY_SIZE:
            raise CryptoError(f"Key must be {self.KEY_SIZE} bytes")
        
        nonce = self.generate_nonce()
        cipher = Cipher(
            algorithms.AES(key),
            modes.GCM(nonce),
            backend=self.backend
        )
        encryptor = cipher.encryptor()
        
        # Add AAD if provided
        if aad:
            encryptor.authenticate_additional_data(aad)
        
        ciphertext = encryptor.update(data) + encryptor.finalize()
        
        # Return nonce and ciphertext (including auth tag)
        return nonce, ciphertext + encryptor.tag
    
    def decrypt(self, nonce: bytes, ciphertext: bytes, key: bytes, aad: bytes = b"") -> bytes:
        """
        Decrypt data using AES-256-GCM.
        
        Args:
            nonce: 12-byte nonce
            ciphertext: Encrypted data with auth tag
            key: 32-byte encryption key
            aad: Additional authenticated data
            
        Returns:
            Decrypted plaintext
        """
        if len(key) != self.KEY_SIZE:
            raise CryptoError(f"Key must be {self.KEY_SIZE} bytes")
        if len(nonce) != self.NONCE_SIZE:
            raise CryptoError(f"Nonce must be {self.NONCE_SIZE} bytes")
        if len(ciphertext) < 16:  # Minimum size for auth tag
            raise CryptoError("Ciphertext too short for auth tag")
        
        # Split ciphertext and tag
        actual_ciphertext = ciphertext[:-16]
        tag = ciphertext[-16:]
        
        cipher = Cipher(
            algorithms.AES(key),
            modes.GCM(nonce, tag),
            backend=self.backend
        )
        decryptor = cipher.decryptor()
        
        # Add AAD if provided
        if aad:
            decryptor.authenticate_additional_data(aad)
        
        plaintext = decryptor.update(actual_ciphertext) + decryptor.finalize()
        return plaintext
    
    def verify_password(self, password: str, salt: bytes, expected_key: bytes) -> bool:
        """
        Verify password by deriving key and comparing with expected key.
        
        Args:
            password: User password to verify
            salt: Salt used for key derivation
            expected_key: Expected derived key
            
        Returns:
            True if password is correct
        """
        try:
            derived_key = self.derive_key(password, salt)
            return derived_key == expected_key
        except CryptoError:
            return False


# Utility functions for binary format handling
def pack_uint16(value: int) -> bytes:
    """Pack unsigned 16-bit integer (big endian)."""
    return struct.pack(">H", value)


def pack_uint32(value: int) -> bytes:
    """Pack unsigned 32-bit integer (big endian)."""
    return struct.pack(">I", value)


def unpack_uint16(data: bytes) -> int:
    """Unpack unsigned 16-bit integer (big endian)."""
    return struct.unpack(">H", data)[0]


def unpack_uint32(data: bytes) -> int:
    """Unpack unsigned 32-bit integer (big endian)."""
    return struct.unpack(">I", data)[0]
